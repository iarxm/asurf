#!/bin/bash

# ============================================
#
# AUTHOR: Iarom Madden
#
# FILE PROCESSING/MOVING
# - Retrieving from sd. Moving and sorting files into session and client dir's. Distributing via rclone
#
# FUNCTIONALITY:
#   - cp: sddcim -> wspace
#   - rc: wsapce -> cloud
#   - sd detection
#   - batch moves
#   - post move syncs/hooks
#   - auto sorting dirs; date; file size
#   - push to remotes; distribution
#
# ================================================


# init cfg

rx="$HOME/xdsa" # root work tree
regx_sdx='/SD_.*|/sd\..*|/LUMIX'
sd_mntx="/home/iao/zm/zm"


# init univ ##########################################

psep="#########################"
prefix="MSURF"
fifo_ds="$XDG_CACHE_HOME/asurf/fifo.dsmv" # TODO: setup fifo w formal code
regx_sd="$regx_sdx"
sd_mnt="$sd_mntx"

# sd / imp
sd_i="" # sd path as arg
sd_m="" # sd path auto matched
sd_r="" # sd root as final sd var
sd_dcim="" # dcim
sd_bkp=""

# workspace
r="$rx" # root work tree
dst_i="" # inputed sub dir
dst=""  # dst full path

  

# funcs ######################################
# print


_prnt_ln()    { printf "%s\n" " "; } # empty line

_prnt_c()     { printf "%s\n" "$1"; } # 'clean' print

_prnt_b()     { printf "$prefix: %s\n" "$1"; }

_prnt_h()     { printf "$prefix: %s\n" "$psep" "# $1" "$psep"; }

_find_d()     { find "$1" -mindepth 1 -maxdepth 1 -type d -exec realpath {} \; ;}

_find_d_grp() { _find_d "$1" | grep -E "$2"; }

_prnp_bkls()  { _find_d "$sd_dcim"; } # move?

_prnp_sd_abs(){ _find_d_grp "$sd_mnt/" "$regx_sd"; } # '../' is required


# exit #########################################

_exit1()      { _prnt_b "exiting (code: 1)" && exit 1; }

_exitx()      { _prnt_b " " ; } #todo


# ops / test #######################################

_assign_a2b()     { [ -n "$2" ] && eval "${2}"="${!1}"; }

_test_dir_exis()  { [ -d "${!1}" ] || { _prnt_b "no { $2 } match; return" && return 1; }; }

_test_dir() { # if dir
  _prnt_b         "dir test:"
  _prnt_b         "checking: { $3 } for existence"
  _test_dir_exis  "$1" "$3"
  [ $? -eq 1 ] && return
  _assign_a2b     "$1" "$2" 
  _prnt_b         "$1 match, setting:"
  _prnt_b         "${2} = ${!2}"; _prnt_ln ;}

_test_dirx()  { [ -n "$2" ] && _test_dir "$1" "$2" "$3"; }


# move ###############################################

_rs()         { _prnt_h "rsync: $1 ---> $2"; rsync -avP "$1" "$2" ; }

_rc_syc()     { src="$1"; dst="$2"; shift 2; rclone sync -vP "$@" --track-renames "$src" "$dst"; }

_mv_loop()    { while IFS= read -r line; do _prnt_b "$3: $line -> $2 "; mv "$line" "$2/"; done <<< "$1"; }


# sd_dcim ######################################

_sd_test_i() { # manual sd dir input
  [ -n "$1" ] || return
  sd_i="$(realpath "$HOME/$sd_i")"
  _test_dirx sd_i sd_r "sd root - as arg" ;}

_sd_test_m() { # regx auto test
  [ -d "sd_r" ] && return
  sd_m="$(_prnp_sd_abs)"
  _test_dirx sd_m sd_r "sd root - regx" ;}

_sd_set_dcim_x() { # if 'src'; then print to fifo
  sd_dcim_x="$sd_r/DCIM/"
  _test_dirx sd_dcim_x sd_dcim "sd dcim"
  [ -d "$sd_dcim" ] || _exit1 ;
  _prnt_b "$sd_dcim: exists 'dcim -> fifo'"
  _prnt_c "$sd_dcim" > "$fifo_ds" # not req now?
  _prnt_ln ;}


# sd meta

_sd_set_dcim() { #1. test sd exist set dcim loc
  [ -d "$sd_dcim" ] && return # TODO: func which returns parent func? possible?
  _sd_test_i
  _sd_test_m
  _sd_set_dcim_x ; }


# sd_mv ######################################

_sd_rs()  { _rs "$sd_dcim/" "$dst"; }

_sd_bkp() { _init_sd_bkp; _mv_loop "$sd_bkls" "$sd_bkp" "sd_dcim bkp:"; }

_sd_srt() { _sort_date_dir_root "$sd_dcim"; }

_sd_mv () { # cp 'sd -> staging area' & mv -> sd/bkp
  _sd_set_dcim
  #_sd_rs
  _sd_bkp ;}


# sd_macro #########################################
_sd_all () { #1. main
  _init_imp "$@"
  #_sort_date_dir_root "$sd_dcim" # todo
  _sd_mv
  _syc_o1x
  #_syc_g1x
}


# SORTING: Client dirs ############################
# TODO:

_mv2client_init() { #
  export dst_root=$1  # client directory
  export dst_root=$1  # source
  export client_pattern="S$2*"  ; } # filename pattern

_dirname_sesh() { dirname $src_file | sed 's,^\(.*/\)\?\([^/]*\),\2,'; }

_client_ls=$(find $client_src_dir -name "*$pattern\.*") #-printf '%h\n'

_mv2client_loop() { for i in $(_client_ls); do _mv2client_x $i $dst_root; done ; }

_mv2client_x() { # session(y) -> client(x)
  mkdir -p "$dst_dir"
  prnt_b "$cl_file -> $cl_dir"
  mv "$1" "$2/$(_sesh_dirname $1)/$(basename $1)" ;}


_mv2client() {
  _mv2client_init
  _mv2client_loop ; }



# sync ##########################################

_syc_x () { 
  r_c="${1}" # cloud root
  i="${2}" # dir feed
  shift 2
  _prnt_h "rclone sync to < $r_c >"
  _rc_syc "$r/$i" "$r_c/$i/" ; }

_syc_g1x () { _syc_x "g1:/xdsa" "$1" ; }

_syc_o1x () { _syc_x "o1:/xdsa" "$1" ; }

# asynchronous ###############################

_init_sd_bkp() {
  sd_bkp="$sd_r/bkp"
  sd_bkls="$(_prnp_bkls)" ;}

_init_imp() {
  dst_i="$1"
  sd_i="$2" 
  dst="$(realpath $r/$dst_i)" ;}


## CASES ==============================
_help() {
  printf "TODO"
}

cmd="${1}" && [ -n "$cmd" ] && shift 1

case $cmd in
  test.sd.exists)   _test_sd_exists ;;
  test.sd)          _test_sd_fifo ;;
  srt.dir.i)        _sort_date_dir "$@" ;; # sort arg dir
  srt.sd)           _srt_sd "$1" ;;
  sy.dvb)           _syc_ext_dvb "$@" ;;
  sy.y21)           _syc_year "$@" ;;
  help)             _help ;;
  # MAIN
  mv.sd)            _mv_sd_i    "" "$@" ;;
  client.x|cl)      _mv_client_profile "$@" ;;
  sy.g1)            _syc_g1x "$@" ;;
  sy.o1)            _syc_o1x "$@" ;;
  sy)               _syc_o1x "$@" ;;
  sd.all)           _sd_all  "$@";;
esac


